<!DOCTYPE html>
<html>
<head>
    <title>IPFS Streaming</title>
    <!-- <link rel="stylesheet" href="css/main.css"> -->
</head>

<body>
    <div id="container">
        <video id="gum" playsinline autoplay muted></video>
        <video id="recorded" playsinline loop></video>
        <div>
            <button id="start">Start camera</button>
            <button id="record" disabled>Start Recording</button>
            <button id="play" disabled>Play</button>
            <button id="download" disabled>Download</button>
        </div>

        <div>
            <h4>Media Stream Constraints options</h4>
            <p>Echo cancellation: <input type="checkbox" id="echoCancellation"></p>
        </div>
        <div>
            <span id="errorMsg"></span>
        </div>
    </div>

    <script type="text/javascript" src="main.js" async></script>

    <!-- include adapter for srcObject shim -->
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

</body>

</html>

<style type="text/css">
    button {
      margin: 0 3px 10px 0;
      padding-left: 2px;
      padding-right: 2px;
      width: 99px;
    }

    button:last-of-type {
      margin: 0;
    }

    p.borderBelow {
      margin: 0 0 20px 0;
      padding: 0 0 20px 0;
    }

    video {
      vertical-align: top;
      --width: 25vw;
      width: var(--width);
      height: calc(var(--width) * 0.5625);
    }

    video:last-of-type {
      margin: 0 0 20px 0;
    }

    video#gumVideo {
      margin: 0 20px 20px 0;
    }
</style>


______________________________________________
        lockFile.lock('temp_folder.lock', function (er) {
            
            // let writeStream = fs.createWriteStream(fd);
            // writeStream.write(message);
            // writeStream.on('finish', () => {  
            //     console.log('wrote all data to file');
            // });

            // writeStream.end();

            // var proc = cp.spawn('ffmpeg', [
            //   '-hide_banner',
            //   '-i', '-',
            //   fd,
            //   '-strict', 
            //   '-profile:v', 'baseline',
            //   '-level', '3.0',
            //   '-start_number', '0',
            //   '-hls_time', '5',
            //   '-hls_list_size', '0',
            //   '-f', 'hls',
            //   'master.m3u8, fd,
            // ]);  
            // console.log("it is ready")
            // proc.stdin.write(message);

            // proc.stdin.end();

            // proc.stderr.pipe(process.stdout);

            // const ffmpeg = spawn('ffmpeg', ['-i', message, '-strict', '-2', '-profile:v', 'baseline', '-level', '3.0', 'start_number', '0', '-hls_time', '5', '-hls_list_size', '0', '-f', `hls`,  fd.m3u8]);

            // ffmpeg.stderr.on('data', (data) => {
            //     console.log`${data}`);


            // });
            // ffmpeg.on('close', (code) => {
            //     // console.log(code);
            //     // resolve();
            // });

            // console.log("The file  saving!");
            // fs.appendFile(fd, message, function (err) {
            //     if (err) {
            //         return console.log(err);
            //     }else{



                    

                    console.log(proc.status);
                    
                    // proc.stdin.write(message);
                    // proc.stdin.end();

                    // proc.stdout.on('data', function(data) {
                    // });



                    // proc.stderr.on('data', function(data) {
                    //     console.log(data.toString()); 
                    // });

                    // proc.on('close', function() {
                    //     console.log('finished');
                    // });

                    // proc.on('exit', function(code) {
                    //     console.log("Exited with code " + code);
                    // });


                    // console.log("The file was saved!, ", fd);
                    
                    // var command = ffmpeg(fd, { timeout: 432000 }).addOptions([
                    //     '-profile:v baseline', // baseline profile (level 3.0) for H264 video codec
                    //     '-level 3.0', 
                    //     '-s 640x360',          // 640px width, 360px height output video dimensions
                    //     '-start_number 0',     // start the first .ts segment at index 0
                    //     '-hls_time 10',        // 10 second segment duration
                    //     '-hls_list_size 0',    // Maxmimum number of playlist entries (0 means all entries/infinite)
                    //     '-f hls'               // HLS format
                    //   ]).output(name).on('end', callback).run()    
                    // console.log(name);
            //     }
                
            // });


            

            lockFile.unlock('temp_folder.lock', function (er) {
                // er means that an error happened, and is probably bad.
            })


        })

        // var testData = new Uint8Array(fs.readFileSync(fd));
        // // Encode test video to VP8.
        // var result = ffmpeg({
        //   MEMFS: [{name: fd, data: testData}],
        //   arguments: ["-i", fd, "test.webm", "-c:v", "libvpx", "-an", "out.webm"],
        //   // Ignore stdin read requests.
        //   stdin: function() {},
        // });
        // // Write out.webm to disk.
        // var out = result.MEMFS[0];
        // fs.writeFileSync(out.name, Buffer(out.data));

          
        // fs.writeFileSync(dir+"/"+date+".mp4", message, function (err) {
        //     if (err) {
        //         return console.log(err);
        //     }
        //     console.log("The file was saved!");
        // });



        // console.log('received: %s', message);
        // console.log(message.type)
        // const toStream = require('buffer-to-stream')
         
        // const readable = toStream(message);
        // ffmpeg(readable, { timeout: 432000 })
        //     .addOption('-level', 3.0)
        //     // size
        //     .addOption('-s','640x360')
        //     // start_number
        //     .addOption('-start_number', 0)
        //     // set hls segments time
        //     .addOption('-hls_time', 10)
        //     // include all the segments in the list
        //     .addOption('-hls_list_size', 0)
        //     // format -f
        //     .format('hls')
        //     // setup event handlers
        //     .on('start', function(cmd) {
        //        console.log('Started ');
        //     })
        //     .on('error', function(err) {
        //       console.log('an error happened: ' + err.message);
        //     })
        //     .on('end', function() {
        //        console.log('File has been converted succesfully');
        //     })
        //

             // .save(dir)

        // ffmpeg(message)
        //   .size('320x240')
        //   .on('error', function(err) {
        //     console.log('An error occurred: ' + err.message);
        //   })
        //   .on('end', function() {
        //     console.log('Processing finished !');
        //   })
        //   .save(dir+"/"+date+".mp4");
        
        // fs.writeFileSync(dir+"/"+date+".webm", message, function (err) {
        //     if (err) {
        //         return console.log(err);
        //     }
        //     console.log("The file was saved!");
        // });